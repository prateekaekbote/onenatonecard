<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>OneNationOneCard — Web NFC Prototype</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="./styles.css">
</head>
<body>
  <div class="header">
    <h2>OneNationOneCard — Web NFC Prototype</h2>
    <a href="https://github.com/prateekaekbote/onenatonecard" target="_blank" rel="noopener noreferrer" class="btn-github">View on GitHub</a>
  </div>

  <div id="supportNotice" class="card"></div>

  <div class="card">
    <h3>1. Fetch details from Database</h3>
    <label>Enter Aadhaar No. <input id="aadhaar" placeholder="123456789012" value="123456789012"></label>
    <button id="fetchBtn">Fetch Data</button>
  </div>
  
  <div id="issuanceSection" class="card disabled-section">
    <h3>2. Request credential from issuer (server)</h3>
    <label>Name <input id="name" readonly></label>
    <label>Sex <input id="sex" readonly></label>
    <label>DOB <input id="dob" readonly></label>
    <label>Voter ID <input id="voter_id" readonly></label>
    <label>PAN <input id="pan" readonly></label>
    <label>Driving License (DL) <input id="dl" readonly></label>
    <label>Photo hash <input id="phash" readonly></label>
    <hr>
    <label>PIN (for tag encryption) <input id="pin" value="7359" type="password"></label>
    <label>Expiry (optional) <input id="expiry" placeholder="2026-10-10"></label>
    <div class="row">
      <button id="requestBtn">Request Issuance (server)</button>
      <button id="writeBtn">Write to tag (after issuing)</button>
    </div>
    <p class="hint">Click <strong>Request Issuance</strong> to get the blob from the server, then tap <strong>Write to tag</strong> and touch the card to your phone.</p>
    <p><strong>Response (server):</strong></p>
    <pre id="serverResp">--</pre>
  </div>

  <div class="card">
    <h3>3. Read & Verify from NFC tag</h3>
    <button id="readBtn">Read tag</button>
    <label>Enter PIN to decrypt <input id="verifyPin" type="password"></label>
    <div class="row">
      <button id="decryptVerifyBtn">Decrypt & Verify</button>
    </div>
    <p class="hint">Press Read tag, then touch the tag to the phone. After the raw blob appears, enter PIN and click Decrypt & Verify.</p>
    <p><strong>Tag raw:</strong></p>
    <pre id="tagRaw">--</pre>
    <p><strong>Decrypted credential (if successful):</strong></p>
    <pre id="credOut">--</pre>
  </div>

<script>
(async () => {
  const supportNotice = document.getElementById("supportNotice");
  const serverResp = document.getElementById("serverResp");
  const tagRaw = document.getElementById("tagRaw");
  const credOut = document.getElementById("credOut");

  // Get all input elements
  const elements = {
      name: document.getElementById("name"),
      sex: document.getElementById("sex"),
      dob: document.getElementById("dob"),
      voter_id: document.getElementById("voter_id"),
      pan: document.getElementById("pan"),
      dl: document.getElementById("dl"),
      phash: document.getElementById("phash"),
      pin: document.getElementById("pin"),
      expiry: document.getElementById("expiry"),
      issuanceSection: document.getElementById("issuanceSection")
  };

  const hasNdefReader = 'NDEFReader' in window;
  const isSecure = window.isSecureContext === true;
  const nfcSupported = hasNdefReader && isSecure;
  if(!nfcSupported){
    let reason = [];
    if(!hasNdefReader) reason.push("NDEFReader API missing");
    if(!isSecure) reason.push("not a secure context (HTTPS/localhost required)");
    const why = reason.length ? ` (${reason.join(', ')})` : '';
    supportNotice.innerHTML = `<strong>Web NFC not available${why}.</strong>`;
  } else {
    supportNotice.innerHTML = `<strong>Web NFC detected.</strong> You can read & write tags.`;
  }

  let lastBlob = null;
  let lastIssuerPubPem = null;
  let lastTagText = null;

  /* --- Fetch user data from server --- */
  document.getElementById("fetchBtn").addEventListener("click", async () => {
    const aadhaar = document.getElementById("aadhaar").value;
    if(!aadhaar) return alert("Please enter an Aadhaar number.");

    try {
        const res = await fetch("/api/fetch_user", {
            method: "POST",
            headers: {"Content-Type":"application/json"},
            body: JSON.stringify({ aadhaar: aadhaar })
        });
        const j = await res.json();
        if(res.ok){
            elements.name.value = j.name;
            elements.sex.value = j.sex;
            elements.dob.value = j.dob;
            elements.voter_id.value = j.voter_id;
            elements.pan.value = j.pan;
            elements.dl.value = j.dl;
            elements.phash.value = j.photo_hash;
            elements.issuanceSection.classList.remove("disabled-section");
            alert("Data fetched successfully. You can now request issuance.");
        } else {
            alert("Error: " + (j.error || "Unknown error"));
        }
    } catch(e) {
        console.error(e);
        alert("Request to fetch user failed: " + e);
    }
  });


  /* --- Call server to issue credential --- */
  document.getElementById("requestBtn").addEventListener("click", async () => {
    // Construct payload with all the new fields
    const payload = {
      name: elements.name.value,
      sex: elements.sex.value,
      dob: elements.dob.value,
      voter_id: elements.voter_id.value,
      pan: elements.pan.value,
      dl: elements.dl.value,
      photo_hash: elements.phash.value,
      pin: elements.pin.value,
      expiry: elements.expiry.value || undefined
    };
    try {
      const res = await fetch("/api/issue_credential", {
        method: "POST",
        headers: {"Content-Type":"application/json"},
        body: JSON.stringify(payload)
      });
      const j = await res.json();
      serverResp.textContent = JSON.stringify(j, null, 2);
      if(j.tag_blob){
        lastBlob = j.tag_blob;
        lastIssuerPubPem = j.issuer_pub_pem;
        alert("Received blob from issuer. Now tap Write to write to tag.");
      } else {
        alert("Server error: " + JSON.stringify(j));
      }
    } catch(e){
      console.error(e);
      alert("Request failed: " + e);
    }
  });

  /* --- Write to NFC tag --- */
  document.getElementById("writeBtn").addEventListener("click", async () => {
    if(!nfcSupported) return alert("Web NFC unsupported");
    if(!lastBlob) return alert("No blob available. Click 'Request Issuance' first.");
    try {
      const ndef = new NDEFReader();
      const encoder = new TextEncoder();
      const dataToWrite = encoder.encode(JSON.stringify(lastBlob));
      await ndef.write({
        records: [
          { recordType: "mime", mediaType: "application/vnd.onenation.cred", data: dataToWrite }
        ]
      });
      alert("Write successful.");
    } catch (e) {
      console.error(e);
      alert("Write failed: " + (e.message || e));
    }
  });

  /* --- Read tag --- */
  document.getElementById("readBtn").addEventListener("click", async () => {
    if(!nfcSupported) return alert("Web NFC unsupported");
    try {
      const ndef = new NDEFReader();
      await ndef.scan();
      tagRaw.textContent = "(waiting for a tag — touch the tag to the phone)";
      ndef.onreadingerror = () => { alert("Read error"); };
      ndef.onreading = event => {
        const records = event.message.records;
        if(records.length === 0) { tagRaw.textContent = "(no records)"; return; }
        let out = [];
        for (const rec of records) {
          try {
            let text = "";
            if(rec.data){
              const dv = rec.data;
              const bytes = new Uint8Array(dv.buffer, dv.byteOffset, dv.byteLength);
              text = new TextDecoder().decode(bytes);
            }
            out.push({t: rec.recordType, m: rec.mediaType || null, d: text});
          } catch(e) {
            out.push({t: rec.recordType, err: String(e)});
          }
        }
        const first = out[0];
        lastTagText = first.d || "";
        tagRaw.textContent = JSON.stringify(out, null, 2);
      };
      alert("Scanning active — touch the tag to your phone now.");
    } catch(e){ console.error(e); alert("Scan failed: " + (e.message || e)); }
  });

  /* --- Decrypt & Verify --- */
  document.getElementById("decryptVerifyBtn").addEventListener("click", async () => {
    if(!lastTagText) return alert("No tag content available. Read a tag first.");
    const pin = document.getElementById("verifyPin").value;
    if(!pin) return alert("Enter PIN used at issuance.");
    let blob;
    try {
      blob = JSON.parse(lastTagText);
    } catch(e){ alert("Tag JSON parse error: " + e); return; }
    try {
      const salt = base64ToArray(blob.salt);
      const nonce = base64ToArray(blob.nonce);
      const ct = base64ToArray(blob.ct);
      const sigDer = base64ToArray(blob.sig);
      const keyBytes = await derivePBKDF2Key(pin, salt, 200000, 256);
      const plain = await aesGcmDecrypt(keyBytes, nonce, ct);
      const plainText = new TextDecoder().decode(plain);
      let issuerPem = lastIssuerPubPem;
      if(!issuerPem){
        issuerPem = prompt("Issuer public key missing. Paste issuer public key PEM here (from server response):");
        if(!issuerPem){ alert("Issuer public key required for verification."); return; }
      }
      const rawSig = derToRaw(sigDer, 32);
      const ok = await verifyEcdsaSignature(issuerPem, plain, rawSig);
      if(!ok) {
        credOut.textContent = "Signature INVALID";
      } else {
        credOut.textContent = plainText;
      }
    } catch (e) {
      console.error(e);
      alert("Decrypt/verify failed: " + (e.message || e));
    }
  });

  /* ---------- Crypto helpers ---------- */
  function base64ToArray(s){
    const bin = atob(s);
    const arr = new Uint8Array(bin.length);
    for(let i=0;i<bin.length;i++) arr[i] = bin.charCodeAt(i);
    return arr;
  }
  async function derivePBKDF2Key(pin, salt, iterations, bits){
    const enc = new TextEncoder();
    const baseKey = await window.crypto.subtle.importKey("raw", enc.encode(pin), {name:"PBKDF2"}, false, ["deriveBits","deriveKey"]);
    const derived = await window.crypto.subtle.deriveKey(
      { name: "PBKDF2", salt: salt, iterations: iterations, hash: "SHA-256" },
      baseKey, { name: "AES-GCM", length: bits }, true, ["encrypt","decrypt"]
    );
    const raw = await window.crypto.subtle.exportKey("raw", derived);
    return new Uint8Array(raw);
  }
  async function aesGcmDecrypt(keyBytes, nonce, ct){
    const cryptoKey = await window.crypto.subtle.importKey("raw", keyBytes, "AES-GCM", false, ["decrypt"]);
    const plain = await window.crypto.subtle.decrypt({name:"AES-GCM", iv: nonce}, cryptoKey, ct);
    return new Uint8Array(plain);
  }
  async function verifyEcdsaSignature(pem, messageBytes, rawSig){
    const pub = pemToArrayBuffer(pem);
    const key = await window.crypto.subtle.importKey("spki", pub, {name:"ECDSA", namedCurve:"P-256"}, false, ["verify"]);
    return await window.crypto.subtle.verify({name:"ECDSA", hash:"SHA-256"}, key, rawSig, messageBytes);
  }
  function pemToArrayBuffer(pem){
    const b64 = pem.replace(/-----(BEGIN|END) PUBLIC KEY-----/g, "").replace(/\s+/g, "");
    const bin = atob(b64);
    const arr = new Uint8Array(bin.length);
    for(let i=0;i<bin.length;i++) arr[i] = bin.charCodeAt(i);
    return arr.buffer;
  }
  function derToRaw(derBytes, partLen){
    const b = derBytes;
    if(b[0] !== 0x30) throw "Bad DER (not sequence)";
    let idx = 2;
    if(b[1] & 0x80){ const lenBytes = b[1] & 0x7f; idx = 2 + lenBytes; }
    if(b[idx] !== 0x02) throw "Bad DER (no int r)";
    const rLen = b[idx+1];
    const rStart = idx+2;
    const r = b.slice(rStart, rStart + rLen);
    const idx2 = rStart + rLen;
    if(b[idx2] !== 0x02) throw "Bad DER (no int s)";
    const sLen = b[idx2+1];
    const sStart = idx2+2;
    const s = b.slice(sStart, sStart + sLen);
    const rPadded = leftPad(r, partLen);
    const sPadded = leftPad(s, partLen);
    const raw = new Uint8Array(partLen*2);
    raw.set(rPadded, 0);
    raw.set(sPadded, partLen);
    return raw.buffer;
  }
  function leftPad(arr, len){
    if(arr.length === len) return arr;
    if(arr.length > len) return arr.slice(arr.length - len);
    const out = new Uint8Array(len);
    out.set(arr, len - arr.length);
    return out;
  }
})();
</script>
</body>
</html>
